// media/mojo/mojom/media_types.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'media/mojo/mojom/media_types.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('media.mojom');
  var mailbox_holder$ =
      mojo.internal.exposeNamespace('gpu.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'gpu/ipc/common/mailbox_holder.mojom', '../../../gpu/ipc/common/mailbox_holder.mojom.js');
  }
  var vulkan_ycbcr_info$ =
      mojo.internal.exposeNamespace('gpu.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'gpu/ipc/common/vulkan_ycbcr_info.mojom', '../../../gpu/ipc/common/vulkan_ycbcr_info.mojom.js');
  }
  var time$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/time.mojom', '../../../mojo/public/mojom/base/time.mojom.js');
  }
  var values$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/values.mojom', '../../../mojo/public/mojom/base/values.mojom.js');
  }
  var unguessable_token$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/unguessable_token.mojom', '../../../mojo/public/mojom/base/unguessable_token.mojom.js');
  }
  var geometry$ =
      mojo.internal.exposeNamespace('gfx.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'ui/gfx/geometry/mojom/geometry.mojom', '../../../ui/gfx/geometry/mojom/geometry.mojom.js');
  }
  var buffer_types$ =
      mojo.internal.exposeNamespace('gfx.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'ui/gfx/mojom/buffer_types.mojom', '../../../ui/gfx/mojom/buffer_types.mojom.js');
  }
  var color_space$ =
      mojo.internal.exposeNamespace('gfx.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'ui/gfx/mojom/color_space.mojom', '../../../ui/gfx/mojom/color_space.mojom.js');
  }
  var hdr_metadata$ =
      mojo.internal.exposeNamespace('gfx.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'ui/gfx/mojom/hdr_metadata.mojom', '../../../ui/gfx/mojom/hdr_metadata.mojom.js');
  }


  var AudioCodec = {};

  AudioCodec.isKnownEnumValue = function(value) {
    return false;
  };

  AudioCodec.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var AudioCodecProfile = {};

  AudioCodecProfile.isKnownEnumValue = function(value) {
    return false;
  };

  AudioCodecProfile.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var BufferingState = {};

  BufferingState.isKnownEnumValue = function(value) {
    return false;
  };

  BufferingState.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var BufferingStateChangeReason = {};

  BufferingStateChangeReason.isKnownEnumValue = function(value) {
    return false;
  };

  BufferingStateChangeReason.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var ChannelLayout = {};

  ChannelLayout.isKnownEnumValue = function(value) {
    return false;
  };

  ChannelLayout.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var DecodeStatus = {};

  DecodeStatus.isKnownEnumValue = function(value) {
    return false;
  };

  DecodeStatus.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var StatusCode = {};

  StatusCode.isKnownEnumValue = function(value) {
    return false;
  };

  StatusCode.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var OutputDeviceStatus = {};

  OutputDeviceStatus.isKnownEnumValue = function(value) {
    return false;
  };

  OutputDeviceStatus.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var PipelineStatus = {};

  PipelineStatus.isKnownEnumValue = function(value) {
    return false;
  };

  PipelineStatus.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var SampleFormat = {};

  SampleFormat.isKnownEnumValue = function(value) {
    return false;
  };

  SampleFormat.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var VideoCodec = {};

  VideoCodec.isKnownEnumValue = function(value) {
    return false;
  };

  VideoCodec.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var VideoCodecProfile = {};

  VideoCodecProfile.isKnownEnumValue = function(value) {
    return false;
  };

  VideoCodecProfile.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var VideoPixelFormat = {};

  VideoPixelFormat.isKnownEnumValue = function(value) {
    return false;
  };

  VideoPixelFormat.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var VideoRotation = {};
  VideoRotation.kVideoRotation0 = 0;
  VideoRotation.kVideoRotation90 = 1;
  VideoRotation.kVideoRotation180 = 2;
  VideoRotation.kVideoRotation270 = 3;
  VideoRotation.MIN_VALUE = 0,
  VideoRotation.MAX_VALUE = 3,

  VideoRotation.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    }
    return false;
  };

  VideoRotation.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var CopyMode = {};
  CopyMode.kCopyToNewTexture = 0;
  CopyMode.kCopyMailboxesOnly = 1;
  CopyMode.MIN_VALUE = 0,
  CopyMode.MAX_VALUE = 1,

  CopyMode.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
      return true;
    }
    return false;
  };

  CopyMode.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var WaitingReason = {};

  WaitingReason.isKnownEnumValue = function(value) {
    return false;
  };

  WaitingReason.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var WatchTimeKey = {};

  WatchTimeKey.isKnownEnumValue = function(value) {
    return false;
  };

  WatchTimeKey.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var MediaContainerName = {};

  MediaContainerName.isKnownEnumValue = function(value) {
    return false;
  };

  MediaContainerName.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var MediaStatusState = {};

  MediaStatusState.isKnownEnumValue = function(value) {
    return false;
  };

  MediaStatusState.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var EncryptionScheme = {};

  EncryptionScheme.isKnownEnumValue = function(value) {
    return false;
  };

  EncryptionScheme.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  function MediaLogRecord(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  MediaLogRecord.prototype.initDefaults_ = function() {
  };
  MediaLogRecord.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  MediaLogRecord.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  MediaLogRecord.encodedSize = codec.kStructHeaderSize + 0;

  MediaLogRecord.decode = function(decoder) {
    var packed;
    var val = new MediaLogRecord();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  MediaLogRecord.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(MediaLogRecord.encodedSize);
    encoder.writeUint32(0);
  };
  function VideoTransformation(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VideoTransformation.prototype.initDefaults_ = function() {
    this.rotation = 0;
    this.mirrored = false;
  };
  VideoTransformation.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VideoTransformation.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoTransformation.rotation
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, VideoRotation);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  VideoTransformation.encodedSize = codec.kStructHeaderSize + 8;

  VideoTransformation.decode = function(decoder) {
    var packed;
    var val = new VideoTransformation();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.rotation =
        decoder.decodeStruct(codec.Int32);
    packed = decoder.readUint8();
    val.mirrored = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  VideoTransformation.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VideoTransformation.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.rotation);
    packed = 0;
    packed |= (val.mirrored & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function EncryptionPattern(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  EncryptionPattern.prototype.initDefaults_ = function() {
    this.cryptByteBlock = 0;
    this.skipByteBlock = 0;
  };
  EncryptionPattern.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  EncryptionPattern.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  EncryptionPattern.encodedSize = codec.kStructHeaderSize + 8;

  EncryptionPattern.decode = function(decoder) {
    var packed;
    var val = new EncryptionPattern();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.cryptByteBlock =
        decoder.decodeStruct(codec.Uint32);
    val.skipByteBlock =
        decoder.decodeStruct(codec.Uint32);
    return val;
  };

  EncryptionPattern.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(EncryptionPattern.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.cryptByteBlock);
    encoder.encodeStruct(codec.Uint32, val.skipByteBlock);
  };
  function VideoColorSpace(values) {
    this.initDefaults_();
    this.initFields_(values);
  }

  VideoColorSpace.PrimaryID = {};

  VideoColorSpace.PrimaryID.isKnownEnumValue = function(value) {
    return false;
  };

  VideoColorSpace.PrimaryID.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  VideoColorSpace.TransferID = {};

  VideoColorSpace.TransferID.isKnownEnumValue = function(value) {
    return false;
  };

  VideoColorSpace.TransferID.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  VideoColorSpace.MatrixID = {};

  VideoColorSpace.MatrixID.isKnownEnumValue = function(value) {
    return false;
  };

  VideoColorSpace.MatrixID.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  VideoColorSpace.RangeID = {};

  VideoColorSpace.RangeID.isKnownEnumValue = function(value) {
    return false;
  };

  VideoColorSpace.RangeID.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  VideoColorSpace.prototype.initDefaults_ = function() {
    this.primaries = 0;
    this.transfer = 0;
    this.matrix = 0;
    this.range = 0;
  };
  VideoColorSpace.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VideoColorSpace.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoColorSpace.primaries
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, VideoColorSpace.PrimaryID);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoColorSpace.transfer
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 4, VideoColorSpace.TransferID);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoColorSpace.matrix
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 8, VideoColorSpace.MatrixID);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoColorSpace.range
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 12, VideoColorSpace.RangeID);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  VideoColorSpace.encodedSize = codec.kStructHeaderSize + 16;

  VideoColorSpace.decode = function(decoder) {
    var packed;
    var val = new VideoColorSpace();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.primaries =
        decoder.decodeStruct(codec.Int32);
    val.transfer =
        decoder.decodeStruct(codec.Int32);
    val.matrix =
        decoder.decodeStruct(codec.Int32);
    val.range =
        decoder.decodeStruct(codec.Int32);
    return val;
  };

  VideoColorSpace.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VideoColorSpace.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.primaries);
    encoder.encodeStruct(codec.Int32, val.transfer);
    encoder.encodeStruct(codec.Int32, val.matrix);
    encoder.encodeStruct(codec.Int32, val.range);
  };
  function AudioDecoderConfig(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  AudioDecoderConfig.prototype.initDefaults_ = function() {
    this.codec = 0;
    this.profile = 0;
    this.sampleFormat = 0;
    this.channelLayout = 0;
    this.samplesPerSecond = 0;
    this.codecDelay = 0;
    this.extraData = null;
    this.seekPreroll = null;
    this.encryptionScheme = 0;
  };
  AudioDecoderConfig.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  AudioDecoderConfig.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 56}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AudioDecoderConfig.codec
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, AudioCodec);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AudioDecoderConfig.profile
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 4, AudioCodecProfile);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AudioDecoderConfig.sampleFormat
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 8, SampleFormat);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AudioDecoderConfig.channelLayout
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 12, ChannelLayout);
    if (err !== validator.validationError.NONE)
        return err;



    // validate AudioDecoderConfig.extraData
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 24, 1, codec.Uint8, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AudioDecoderConfig.seekPreroll
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;



    // validate AudioDecoderConfig.encryptionScheme
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 40, EncryptionScheme);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  AudioDecoderConfig.encodedSize = codec.kStructHeaderSize + 48;

  AudioDecoderConfig.decode = function(decoder) {
    var packed;
    var val = new AudioDecoderConfig();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.codec =
        decoder.decodeStruct(codec.Int32);
    val.profile =
        decoder.decodeStruct(codec.Int32);
    val.sampleFormat =
        decoder.decodeStruct(codec.Int32);
    val.channelLayout =
        decoder.decodeStruct(codec.Int32);
    val.samplesPerSecond =
        decoder.decodeStruct(codec.Int32);
    val.codecDelay =
        decoder.decodeStruct(codec.Int32);
    val.extraData =
        decoder.decodeArrayPointer(codec.Uint8);
    val.seekPreroll =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.encryptionScheme =
        decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  AudioDecoderConfig.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(AudioDecoderConfig.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.codec);
    encoder.encodeStruct(codec.Int32, val.profile);
    encoder.encodeStruct(codec.Int32, val.sampleFormat);
    encoder.encodeStruct(codec.Int32, val.channelLayout);
    encoder.encodeStruct(codec.Int32, val.samplesPerSecond);
    encoder.encodeStruct(codec.Int32, val.codecDelay);
    encoder.encodeArrayPointer(codec.Uint8, val.extraData);
    encoder.encodeStructPointer(time$.TimeDelta, val.seekPreroll);
    encoder.encodeStruct(codec.Int32, val.encryptionScheme);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function VideoDecoderConfig(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VideoDecoderConfig.prototype.initDefaults_ = function() {
    this.codec = 0;
    this.profile = 0;
    this.level = 0;
    this.hasAlpha = false;
    this.transformation = null;
    this.codedSize = null;
    this.visibleRect = null;
    this.naturalSize = null;
    this.extraData = null;
    this.encryptionScheme = 0;
    this.colorSpaceInfo = null;
    this.hdrMetadata = null;
  };
  VideoDecoderConfig.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VideoDecoderConfig.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 88}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoDecoderConfig.codec
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, VideoCodec);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoDecoderConfig.profile
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 4, VideoCodecProfile);
    if (err !== validator.validationError.NONE)
        return err;




    // validate VideoDecoderConfig.transformation
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, VideoTransformation, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoDecoderConfig.codedSize
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, geometry$.Size, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoDecoderConfig.visibleRect
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, geometry$.Rect, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoDecoderConfig.naturalSize
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, geometry$.Size, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoDecoderConfig.extraData
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 48, 1, codec.Uint8, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoDecoderConfig.encryptionScheme
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 56, EncryptionScheme);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoDecoderConfig.colorSpaceInfo
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 64, VideoColorSpace, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoDecoderConfig.hdrMetadata
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 72, hdr_metadata$.HDRMetadata, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  VideoDecoderConfig.encodedSize = codec.kStructHeaderSize + 80;

  VideoDecoderConfig.decode = function(decoder) {
    var packed;
    var val = new VideoDecoderConfig();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.codec =
        decoder.decodeStruct(codec.Int32);
    val.profile =
        decoder.decodeStruct(codec.Int32);
    val.level =
        decoder.decodeStruct(codec.Uint32);
    packed = decoder.readUint8();
    val.hasAlpha = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.transformation =
        decoder.decodeStructPointer(VideoTransformation);
    val.codedSize =
        decoder.decodeStructPointer(geometry$.Size);
    val.visibleRect =
        decoder.decodeStructPointer(geometry$.Rect);
    val.naturalSize =
        decoder.decodeStructPointer(geometry$.Size);
    val.extraData =
        decoder.decodeArrayPointer(codec.Uint8);
    val.encryptionScheme =
        decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.colorSpaceInfo =
        decoder.decodeStructPointer(VideoColorSpace);
    val.hdrMetadata =
        decoder.decodeStructPointer(hdr_metadata$.HDRMetadata);
    return val;
  };

  VideoDecoderConfig.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VideoDecoderConfig.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.codec);
    encoder.encodeStruct(codec.Int32, val.profile);
    encoder.encodeStruct(codec.Uint32, val.level);
    packed = 0;
    packed |= (val.hasAlpha & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(VideoTransformation, val.transformation);
    encoder.encodeStructPointer(geometry$.Size, val.codedSize);
    encoder.encodeStructPointer(geometry$.Rect, val.visibleRect);
    encoder.encodeStructPointer(geometry$.Size, val.naturalSize);
    encoder.encodeArrayPointer(codec.Uint8, val.extraData);
    encoder.encodeStruct(codec.Int32, val.encryptionScheme);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(VideoColorSpace, val.colorSpaceInfo);
    encoder.encodeStructPointer(hdr_metadata$.HDRMetadata, val.hdrMetadata);
  };
  function SubsampleEntry(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SubsampleEntry.prototype.initDefaults_ = function() {
  };
  SubsampleEntry.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SubsampleEntry.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SubsampleEntry.encodedSize = codec.kStructHeaderSize + 0;

  SubsampleEntry.decode = function(decoder) {
    var packed;
    var val = new SubsampleEntry();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  SubsampleEntry.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SubsampleEntry.encodedSize);
    encoder.writeUint32(0);
  };
  function DecryptConfig(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  DecryptConfig.prototype.initDefaults_ = function() {
    this.encryptionScheme = 0;
    this.keyId = null;
    this.iv = null;
    this.subsamples = null;
    this.encryptionPattern = null;
  };
  DecryptConfig.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  DecryptConfig.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 48}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DecryptConfig.encryptionScheme
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, EncryptionScheme);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DecryptConfig.keyId
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 8, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate DecryptConfig.iv
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 16, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate DecryptConfig.subsamples
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 24, 8, new codec.PointerTo(SubsampleEntry), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DecryptConfig.encryptionPattern
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, EncryptionPattern, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  DecryptConfig.encodedSize = codec.kStructHeaderSize + 40;

  DecryptConfig.decode = function(decoder) {
    var packed;
    var val = new DecryptConfig();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.encryptionScheme =
        decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.keyId =
        decoder.decodeStruct(codec.String);
    val.iv =
        decoder.decodeStruct(codec.String);
    val.subsamples =
        decoder.decodeArrayPointer(new codec.PointerTo(SubsampleEntry));
    val.encryptionPattern =
        decoder.decodeStructPointer(EncryptionPattern);
    return val;
  };

  DecryptConfig.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(DecryptConfig.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.encryptionScheme);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.String, val.keyId);
    encoder.encodeStruct(codec.String, val.iv);
    encoder.encodeArrayPointer(new codec.PointerTo(SubsampleEntry), val.subsamples);
    encoder.encodeStructPointer(EncryptionPattern, val.encryptionPattern);
  };
  function DecoderBuffer(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  DecoderBuffer.prototype.initDefaults_ = function() {
    this.timestamp = null;
    this.duration = null;
    this.isEndOfStream = false;
    this.isKeyFrame = false;
    this.dataSize = 0;
    this.sideData = null;
    this.decryptConfig = null;
    this.frontDiscard = null;
    this.backDiscard = null;
  };
  DecoderBuffer.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  DecoderBuffer.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 64}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DecoderBuffer.timestamp
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DecoderBuffer.duration
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;





    // validate DecoderBuffer.sideData
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 24, 1, codec.Uint8, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DecoderBuffer.decryptConfig
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, DecryptConfig, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DecoderBuffer.frontDiscard
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DecoderBuffer.backDiscard
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 48, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  DecoderBuffer.encodedSize = codec.kStructHeaderSize + 56;

  DecoderBuffer.decode = function(decoder) {
    var packed;
    var val = new DecoderBuffer();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.timestamp =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.duration =
        decoder.decodeStructPointer(time$.TimeDelta);
    packed = decoder.readUint8();
    val.isEndOfStream = (packed >> 0) & 1 ? true : false;
    val.isKeyFrame = (packed >> 1) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.dataSize =
        decoder.decodeStruct(codec.Uint32);
    val.sideData =
        decoder.decodeArrayPointer(codec.Uint8);
    val.decryptConfig =
        decoder.decodeStructPointer(DecryptConfig);
    val.frontDiscard =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.backDiscard =
        decoder.decodeStructPointer(time$.TimeDelta);
    return val;
  };

  DecoderBuffer.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(DecoderBuffer.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(time$.TimeDelta, val.timestamp);
    encoder.encodeStructPointer(time$.TimeDelta, val.duration);
    packed = 0;
    packed |= (val.isEndOfStream & 1) << 0
    packed |= (val.isKeyFrame & 1) << 1
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Uint32, val.dataSize);
    encoder.encodeArrayPointer(codec.Uint8, val.sideData);
    encoder.encodeStructPointer(DecryptConfig, val.decryptConfig);
    encoder.encodeStructPointer(time$.TimeDelta, val.frontDiscard);
    encoder.encodeStructPointer(time$.TimeDelta, val.backDiscard);
  };
  function AudioBuffer(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  AudioBuffer.prototype.initDefaults_ = function() {
    this.sampleFormat = 0;
    this.channelLayout = 0;
    this.channelCount = 0;
    this.sampleRate = 0;
    this.frameCount = 0;
    this.endOfStream = false;
    this.timestamp = null;
    this.data = null;
  };
  AudioBuffer.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  AudioBuffer.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 48}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AudioBuffer.sampleFormat
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, SampleFormat);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AudioBuffer.channelLayout
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 4, ChannelLayout);
    if (err !== validator.validationError.NONE)
        return err;






    // validate AudioBuffer.timestamp
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AudioBuffer.data
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 32, 1, codec.Uint8, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  AudioBuffer.encodedSize = codec.kStructHeaderSize + 40;

  AudioBuffer.decode = function(decoder) {
    var packed;
    var val = new AudioBuffer();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.sampleFormat =
        decoder.decodeStruct(codec.Int32);
    val.channelLayout =
        decoder.decodeStruct(codec.Int32);
    val.channelCount =
        decoder.decodeStruct(codec.Int32);
    val.sampleRate =
        decoder.decodeStruct(codec.Int32);
    val.frameCount =
        decoder.decodeStruct(codec.Int32);
    packed = decoder.readUint8();
    val.endOfStream = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.timestamp =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.data =
        decoder.decodeArrayPointer(codec.Uint8);
    return val;
  };

  AudioBuffer.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(AudioBuffer.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.sampleFormat);
    encoder.encodeStruct(codec.Int32, val.channelLayout);
    encoder.encodeStruct(codec.Int32, val.channelCount);
    encoder.encodeStruct(codec.Int32, val.sampleRate);
    encoder.encodeStruct(codec.Int32, val.frameCount);
    packed = 0;
    packed |= (val.endOfStream & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(time$.TimeDelta, val.timestamp);
    encoder.encodeArrayPointer(codec.Uint8, val.data);
  };
  function AudioDataS16(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  AudioDataS16.prototype.initDefaults_ = function() {
    this.channelCount = 0;
    this.sampleRate = 0;
    this.frameCount = 0;
    this.data = null;
  };
  AudioDataS16.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  AudioDataS16.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;





    // validate AudioDataS16.data
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 16, 2, codec.Int16, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  AudioDataS16.encodedSize = codec.kStructHeaderSize + 24;

  AudioDataS16.decode = function(decoder) {
    var packed;
    var val = new AudioDataS16();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.channelCount =
        decoder.decodeStruct(codec.Int32);
    val.sampleRate =
        decoder.decodeStruct(codec.Int32);
    val.frameCount =
        decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.data =
        decoder.decodeArrayPointer(codec.Int16);
    return val;
  };

  AudioDataS16.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(AudioDataS16.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.channelCount);
    encoder.encodeStruct(codec.Int32, val.sampleRate);
    encoder.encodeStruct(codec.Int32, val.frameCount);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeArrayPointer(codec.Int16, val.data);
  };
  function VideoFrameMetadata(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VideoFrameMetadata.prototype.initDefaults_ = function() {
    this.allowOverlay = false;
    this.hasCaptureCounter = false;
    this.hasCopyMode = false;
    this.endOfStream = false;
    this.hasFrameRate = false;
    this.interactiveContent = false;
    this.readLockFencesEnabled = false;
    this.hasRotation = false;
    this.textureOwner = false;
    this.wantsPromotionHint = false;
    this.protectedVideo = false;
    this.hwProtected = false;
    this.powerEfficient = false;
    this.hasDeviceScaleFactor = false;
    this.hasPageScaleFactor = false;
    this.hasRootScrollOffsetX = false;
    this.hasRootScrollOffsetY = false;
    this.hasTopControlsVisibleHeight = false;
    this.hasRtpTimestamp = false;
    this.captureCounter = 0;
    this.captureBeginTime = null;
    this.captureEndTime = null;
    this.captureUpdateRect = null;
    this.copyMode = 0;
    this.rotation = 0;
    this.frameDuration = null;
    this.frameRate = 0;
    this.referenceTime = null;
    this.overlayPlaneId = null;
    this.deviceScaleFactor = 0;
    this.pageScaleFactor = 0;
    this.rootScrollOffsetX = 0;
    this.rootScrollOffsetY = 0;
    this.topControlsVisibleHeight = 0;
    this.decodeBeginTime = null;
    this.decodeEndTime = null;
    this.processingTime = null;
    this.rtpTimestamp = 0;
    this.receiveTime = null;
    this.wallclockFrameDuration = null;
    this.hwProtectedValidationId = 0;
  };
  VideoFrameMetadata.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VideoFrameMetadata.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 176}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate VideoFrameMetadata.captureBeginTime
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, time$.TimeTicks, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoFrameMetadata.captureEndTime
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, time$.TimeTicks, true);
    if (err !== validator.validationError.NONE)
        return err;




    // validate VideoFrameMetadata.captureUpdateRect
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, geometry$.Rect, true);
    if (err !== validator.validationError.NONE)
        return err;



    // validate VideoFrameMetadata.copyMode
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 32, CopyMode);
    if (err !== validator.validationError.NONE)
        return err;



    // validate VideoFrameMetadata.frameDuration
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;





    // validate VideoFrameMetadata.referenceTime
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 56, time$.TimeTicks, true);
    if (err !== validator.validationError.NONE)
        return err;




    // validate VideoFrameMetadata.rotation
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 36, VideoRotation);
    if (err !== validator.validationError.NONE)
        return err;






    // validate VideoFrameMetadata.overlayPlaneId
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 64, unguessable_token$.UnguessableToken, true);
    if (err !== validator.validationError.NONE)
        return err;













    // validate VideoFrameMetadata.decodeBeginTime
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 112, time$.TimeTicks, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoFrameMetadata.decodeEndTime
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 120, time$.TimeTicks, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoFrameMetadata.processingTime
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 128, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;




    // validate VideoFrameMetadata.receiveTime
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 144, time$.TimeTicks, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoFrameMetadata.wallclockFrameDuration
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 152, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  VideoFrameMetadata.encodedSize = codec.kStructHeaderSize + 168;

  VideoFrameMetadata.decode = function(decoder) {
    var packed;
    var val = new VideoFrameMetadata();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.allowOverlay = (packed >> 0) & 1 ? true : false;
    val.hasCaptureCounter = (packed >> 1) & 1 ? true : false;
    val.hasCopyMode = (packed >> 2) & 1 ? true : false;
    val.endOfStream = (packed >> 3) & 1 ? true : false;
    val.hasFrameRate = (packed >> 4) & 1 ? true : false;
    val.interactiveContent = (packed >> 5) & 1 ? true : false;
    val.readLockFencesEnabled = (packed >> 6) & 1 ? true : false;
    val.hasRotation = (packed >> 7) & 1 ? true : false;
    packed = decoder.readUint8();
    val.textureOwner = (packed >> 0) & 1 ? true : false;
    val.wantsPromotionHint = (packed >> 1) & 1 ? true : false;
    val.protectedVideo = (packed >> 2) & 1 ? true : false;
    val.hwProtected = (packed >> 3) & 1 ? true : false;
    val.powerEfficient = (packed >> 4) & 1 ? true : false;
    val.hasDeviceScaleFactor = (packed >> 5) & 1 ? true : false;
    val.hasPageScaleFactor = (packed >> 6) & 1 ? true : false;
    val.hasRootScrollOffsetX = (packed >> 7) & 1 ? true : false;
    packed = decoder.readUint8();
    val.hasRootScrollOffsetY = (packed >> 0) & 1 ? true : false;
    val.hasTopControlsVisibleHeight = (packed >> 1) & 1 ? true : false;
    val.hasRtpTimestamp = (packed >> 2) & 1 ? true : false;
    decoder.skip(1);
    val.captureCounter =
        decoder.decodeStruct(codec.Int32);
    val.captureBeginTime =
        decoder.decodeStructPointer(time$.TimeTicks);
    val.captureEndTime =
        decoder.decodeStructPointer(time$.TimeTicks);
    val.captureUpdateRect =
        decoder.decodeStructPointer(geometry$.Rect);
    val.copyMode =
        decoder.decodeStruct(codec.Int32);
    val.rotation =
        decoder.decodeStruct(codec.Int32);
    val.frameDuration =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.frameRate =
        decoder.decodeStruct(codec.Double);
    val.referenceTime =
        decoder.decodeStructPointer(time$.TimeTicks);
    val.overlayPlaneId =
        decoder.decodeStructPointer(unguessable_token$.UnguessableToken);
    val.deviceScaleFactor =
        decoder.decodeStruct(codec.Double);
    val.pageScaleFactor =
        decoder.decodeStruct(codec.Double);
    val.rootScrollOffsetX =
        decoder.decodeStruct(codec.Double);
    val.rootScrollOffsetY =
        decoder.decodeStruct(codec.Double);
    val.topControlsVisibleHeight =
        decoder.decodeStruct(codec.Double);
    val.decodeBeginTime =
        decoder.decodeStructPointer(time$.TimeTicks);
    val.decodeEndTime =
        decoder.decodeStructPointer(time$.TimeTicks);
    val.processingTime =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.rtpTimestamp =
        decoder.decodeStruct(codec.Double);
    val.receiveTime =
        decoder.decodeStructPointer(time$.TimeTicks);
    val.wallclockFrameDuration =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.hwProtectedValidationId =
        decoder.decodeStruct(codec.Uint32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  VideoFrameMetadata.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VideoFrameMetadata.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.allowOverlay & 1) << 0
    packed |= (val.hasCaptureCounter & 1) << 1
    packed |= (val.hasCopyMode & 1) << 2
    packed |= (val.endOfStream & 1) << 3
    packed |= (val.hasFrameRate & 1) << 4
    packed |= (val.interactiveContent & 1) << 5
    packed |= (val.readLockFencesEnabled & 1) << 6
    packed |= (val.hasRotation & 1) << 7
    encoder.writeUint8(packed);
    packed = 0;
    packed |= (val.textureOwner & 1) << 0
    packed |= (val.wantsPromotionHint & 1) << 1
    packed |= (val.protectedVideo & 1) << 2
    packed |= (val.hwProtected & 1) << 3
    packed |= (val.powerEfficient & 1) << 4
    packed |= (val.hasDeviceScaleFactor & 1) << 5
    packed |= (val.hasPageScaleFactor & 1) << 6
    packed |= (val.hasRootScrollOffsetX & 1) << 7
    encoder.writeUint8(packed);
    packed = 0;
    packed |= (val.hasRootScrollOffsetY & 1) << 0
    packed |= (val.hasTopControlsVisibleHeight & 1) << 1
    packed |= (val.hasRtpTimestamp & 1) << 2
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.encodeStruct(codec.Int32, val.captureCounter);
    encoder.encodeStructPointer(time$.TimeTicks, val.captureBeginTime);
    encoder.encodeStructPointer(time$.TimeTicks, val.captureEndTime);
    encoder.encodeStructPointer(geometry$.Rect, val.captureUpdateRect);
    encoder.encodeStruct(codec.Int32, val.copyMode);
    encoder.encodeStruct(codec.Int32, val.rotation);
    encoder.encodeStructPointer(time$.TimeDelta, val.frameDuration);
    encoder.encodeStruct(codec.Double, val.frameRate);
    encoder.encodeStructPointer(time$.TimeTicks, val.referenceTime);
    encoder.encodeStructPointer(unguessable_token$.UnguessableToken, val.overlayPlaneId);
    encoder.encodeStruct(codec.Double, val.deviceScaleFactor);
    encoder.encodeStruct(codec.Double, val.pageScaleFactor);
    encoder.encodeStruct(codec.Double, val.rootScrollOffsetX);
    encoder.encodeStruct(codec.Double, val.rootScrollOffsetY);
    encoder.encodeStruct(codec.Double, val.topControlsVisibleHeight);
    encoder.encodeStructPointer(time$.TimeTicks, val.decodeBeginTime);
    encoder.encodeStructPointer(time$.TimeTicks, val.decodeEndTime);
    encoder.encodeStructPointer(time$.TimeDelta, val.processingTime);
    encoder.encodeStruct(codec.Double, val.rtpTimestamp);
    encoder.encodeStructPointer(time$.TimeTicks, val.receiveTime);
    encoder.encodeStructPointer(time$.TimeDelta, val.wallclockFrameDuration);
    encoder.encodeStruct(codec.Uint32, val.hwProtectedValidationId);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function VideoFrame(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VideoFrame.prototype.initDefaults_ = function() {
    this.format = 0;
    this.codedSize = null;
    this.visibleRect = null;
    this.naturalSize = null;
    this.timestamp = null;
    this.data = null;
    this.metadata = null;
    this.colorSpace = null;
    this.hdrMetadata = null;
  };
  VideoFrame.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VideoFrame.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 88}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoFrame.format
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, VideoPixelFormat);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoFrame.codedSize
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, geometry$.Size, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoFrame.visibleRect
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, geometry$.Rect, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoFrame.naturalSize
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, geometry$.Size, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoFrame.timestamp
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoFrame.data
    err = messageValidator.validateUnion(offset + codec.kStructHeaderSize + 40, VideoFrameData, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoFrame.metadata
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 56, VideoFrameMetadata, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoFrame.colorSpace
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 64, color_space$.ColorSpace, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoFrame.hdrMetadata
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 72, hdr_metadata$.HDRMetadata, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  VideoFrame.encodedSize = codec.kStructHeaderSize + 80;

  VideoFrame.decode = function(decoder) {
    var packed;
    var val = new VideoFrame();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.format =
        decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.codedSize =
        decoder.decodeStructPointer(geometry$.Size);
    val.visibleRect =
        decoder.decodeStructPointer(geometry$.Rect);
    val.naturalSize =
        decoder.decodeStructPointer(geometry$.Size);
    val.timestamp =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.data =
        decoder.decodeStruct(VideoFrameData);
    val.metadata =
        decoder.decodeStructPointer(VideoFrameMetadata);
    val.colorSpace =
        decoder.decodeStructPointer(color_space$.ColorSpace);
    val.hdrMetadata =
        decoder.decodeStructPointer(hdr_metadata$.HDRMetadata);
    return val;
  };

  VideoFrame.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VideoFrame.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.format);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(geometry$.Size, val.codedSize);
    encoder.encodeStructPointer(geometry$.Rect, val.visibleRect);
    encoder.encodeStructPointer(geometry$.Size, val.naturalSize);
    encoder.encodeStructPointer(time$.TimeDelta, val.timestamp);
    encoder.encodeStruct(VideoFrameData, val.data);
    encoder.encodeStructPointer(VideoFrameMetadata, val.metadata);
    encoder.encodeStructPointer(color_space$.ColorSpace, val.colorSpace);
    encoder.encodeStructPointer(hdr_metadata$.HDRMetadata, val.hdrMetadata);
  };
  function EosVideoFrameData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  EosVideoFrameData.prototype.initDefaults_ = function() {
  };
  EosVideoFrameData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  EosVideoFrameData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  EosVideoFrameData.encodedSize = codec.kStructHeaderSize + 0;

  EosVideoFrameData.decode = function(decoder) {
    var packed;
    var val = new EosVideoFrameData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  EosVideoFrameData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(EosVideoFrameData.encodedSize);
    encoder.writeUint32(0);
  };
  function SharedBufferVideoFrameData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SharedBufferVideoFrameData.prototype.initDefaults_ = function() {
    this.frameData = null;
    this.frameDataSize = 0;
    this.strides = null;
    this.offsets = null;
  };
  SharedBufferVideoFrameData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SharedBufferVideoFrameData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 40}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SharedBufferVideoFrameData.frameData
    err = messageValidator.validateHandle(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;



    // validate SharedBufferVideoFrameData.strides
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 16, 4, codec.Int32, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SharedBufferVideoFrameData.offsets
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 24, 4, codec.Uint32, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SharedBufferVideoFrameData.encodedSize = codec.kStructHeaderSize + 32;

  SharedBufferVideoFrameData.decode = function(decoder) {
    var packed;
    var val = new SharedBufferVideoFrameData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.frameData =
        decoder.decodeStruct(codec.Handle);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.frameDataSize =
        decoder.decodeStruct(codec.Uint64);
    val.strides =
        decoder.decodeArrayPointer(codec.Int32);
    val.offsets =
        decoder.decodeArrayPointer(codec.Uint32);
    return val;
  };

  SharedBufferVideoFrameData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SharedBufferVideoFrameData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Handle, val.frameData);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Uint64, val.frameDataSize);
    encoder.encodeArrayPointer(codec.Int32, val.strides);
    encoder.encodeArrayPointer(codec.Uint32, val.offsets);
  };
  function DmabufVideoFrameData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  DmabufVideoFrameData.prototype.initDefaults_ = function() {
    this.dmabufFds = null;
  };
  DmabufVideoFrameData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  DmabufVideoFrameData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DmabufVideoFrameData.dmabufFds
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 4, codec.Handle, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  DmabufVideoFrameData.encodedSize = codec.kStructHeaderSize + 8;

  DmabufVideoFrameData.decode = function(decoder) {
    var packed;
    var val = new DmabufVideoFrameData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.dmabufFds =
        decoder.decodeArrayPointer(codec.Handle);
    return val;
  };

  DmabufVideoFrameData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(DmabufVideoFrameData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeArrayPointer(codec.Handle, val.dmabufFds);
  };
  function GpuMemoryBufferVideoFrameData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GpuMemoryBufferVideoFrameData.prototype.initDefaults_ = function() {
    this.gpuMemoryBufferHandle = null;
    this.mailboxHolder = null;
  };
  GpuMemoryBufferVideoFrameData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GpuMemoryBufferVideoFrameData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GpuMemoryBufferVideoFrameData.gpuMemoryBufferHandle
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, buffer_types$.GpuMemoryBufferHandle, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GpuMemoryBufferVideoFrameData.mailboxHolder
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 8, new codec.PointerTo(mailbox_holder$.MailboxHolder), false, [4], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GpuMemoryBufferVideoFrameData.encodedSize = codec.kStructHeaderSize + 16;

  GpuMemoryBufferVideoFrameData.decode = function(decoder) {
    var packed;
    var val = new GpuMemoryBufferVideoFrameData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.gpuMemoryBufferHandle =
        decoder.decodeStructPointer(buffer_types$.GpuMemoryBufferHandle);
    val.mailboxHolder =
        decoder.decodeArrayPointer(new codec.PointerTo(mailbox_holder$.MailboxHolder));
    return val;
  };

  GpuMemoryBufferVideoFrameData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GpuMemoryBufferVideoFrameData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(buffer_types$.GpuMemoryBufferHandle, val.gpuMemoryBufferHandle);
    encoder.encodeArrayPointer(new codec.PointerTo(mailbox_holder$.MailboxHolder), val.mailboxHolder);
  };
  function MailboxVideoFrameData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  MailboxVideoFrameData.prototype.initDefaults_ = function() {
    this.mailboxHolder = null;
    this.ycbcrData = null;
  };
  MailboxVideoFrameData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  MailboxVideoFrameData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate MailboxVideoFrameData.mailboxHolder
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 8, new codec.PointerTo(mailbox_holder$.MailboxHolder), false, [4], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate MailboxVideoFrameData.ycbcrData
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, vulkan_ycbcr_info$.VulkanYCbCrInfo, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  MailboxVideoFrameData.encodedSize = codec.kStructHeaderSize + 16;

  MailboxVideoFrameData.decode = function(decoder) {
    var packed;
    var val = new MailboxVideoFrameData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.mailboxHolder =
        decoder.decodeArrayPointer(new codec.PointerTo(mailbox_holder$.MailboxHolder));
    val.ycbcrData =
        decoder.decodeStructPointer(vulkan_ycbcr_info$.VulkanYCbCrInfo);
    return val;
  };

  MailboxVideoFrameData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(MailboxVideoFrameData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeArrayPointer(new codec.PointerTo(mailbox_holder$.MailboxHolder), val.mailboxHolder);
    encoder.encodeStructPointer(vulkan_ycbcr_info$.VulkanYCbCrInfo, val.ycbcrData);
  };
  function PipelineStatistics(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PipelineStatistics.prototype.initDefaults_ = function() {
    this.audioBytesDecoded = 0;
    this.videoBytesDecoded = 0;
    this.videoFramesDecoded = 0;
    this.videoFramesDropped = 0;
    this.audioMemoryUsage = 0;
    this.videoMemoryUsage = 0;
  };
  PipelineStatistics.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PipelineStatistics.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 48}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;







    return validator.validationError.NONE;
  };

  PipelineStatistics.encodedSize = codec.kStructHeaderSize + 40;

  PipelineStatistics.decode = function(decoder) {
    var packed;
    var val = new PipelineStatistics();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.audioBytesDecoded =
        decoder.decodeStruct(codec.Uint64);
    val.videoBytesDecoded =
        decoder.decodeStruct(codec.Uint64);
    val.videoFramesDecoded =
        decoder.decodeStruct(codec.Uint32);
    val.videoFramesDropped =
        decoder.decodeStruct(codec.Uint32);
    val.audioMemoryUsage =
        decoder.decodeStruct(codec.Int64);
    val.videoMemoryUsage =
        decoder.decodeStruct(codec.Int64);
    return val;
  };

  PipelineStatistics.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PipelineStatistics.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint64, val.audioBytesDecoded);
    encoder.encodeStruct(codec.Uint64, val.videoBytesDecoded);
    encoder.encodeStruct(codec.Uint32, val.videoFramesDecoded);
    encoder.encodeStruct(codec.Uint32, val.videoFramesDropped);
    encoder.encodeStruct(codec.Int64, val.audioMemoryUsage);
    encoder.encodeStruct(codec.Int64, val.videoMemoryUsage);
  };
  function PredictionFeatures(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PredictionFeatures.prototype.initDefaults_ = function() {
    this.profile = 0;
    this.useHwSecureCodecs = false;
    this.videoSize = null;
    this.framesPerSec = 0;
    this.keySystem = null;
  };
  PredictionFeatures.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PredictionFeatures.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 40}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PredictionFeatures.profile
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, VideoCodecProfile);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PredictionFeatures.videoSize
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, geometry$.Size, false);
    if (err !== validator.validationError.NONE)
        return err;



    // validate PredictionFeatures.keySystem
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 24, false)
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  PredictionFeatures.encodedSize = codec.kStructHeaderSize + 32;

  PredictionFeatures.decode = function(decoder) {
    var packed;
    var val = new PredictionFeatures();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.profile =
        decoder.decodeStruct(codec.Int32);
    packed = decoder.readUint8();
    val.useHwSecureCodecs = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.videoSize =
        decoder.decodeStructPointer(geometry$.Size);
    val.framesPerSec =
        decoder.decodeStruct(codec.Double);
    val.keySystem =
        decoder.decodeStruct(codec.String);
    return val;
  };

  PredictionFeatures.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PredictionFeatures.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.profile);
    packed = 0;
    packed |= (val.useHwSecureCodecs & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(geometry$.Size, val.videoSize);
    encoder.encodeStruct(codec.Double, val.framesPerSec);
    encoder.encodeStruct(codec.String, val.keySystem);
  };
  function PredictionTargets(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PredictionTargets.prototype.initDefaults_ = function() {
    this.framesDecoded = 0;
    this.framesDropped = 0;
    this.framesPowerEfficient = 0;
  };
  PredictionTargets.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PredictionTargets.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;




    return validator.validationError.NONE;
  };

  PredictionTargets.encodedSize = codec.kStructHeaderSize + 16;

  PredictionTargets.decode = function(decoder) {
    var packed;
    var val = new PredictionTargets();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.framesDecoded =
        decoder.decodeStruct(codec.Uint32);
    val.framesDropped =
        decoder.decodeStruct(codec.Uint32);
    val.framesPowerEfficient =
        decoder.decodeStruct(codec.Uint32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  PredictionTargets.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PredictionTargets.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.framesDecoded);
    encoder.encodeStruct(codec.Uint32, val.framesDropped);
    encoder.encodeStruct(codec.Uint32, val.framesPowerEfficient);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function PipelineDecoderInfo(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PipelineDecoderInfo.prototype.initDefaults_ = function() {
    this.decoderName = null;
    this.isPlatformDecoder = false;
    this.hasDecryptingDemuxerStream = false;
  };
  PipelineDecoderInfo.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PipelineDecoderInfo.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PipelineDecoderInfo.decoderName
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  PipelineDecoderInfo.encodedSize = codec.kStructHeaderSize + 16;

  PipelineDecoderInfo.decode = function(decoder) {
    var packed;
    var val = new PipelineDecoderInfo();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.decoderName =
        decoder.decodeStruct(codec.String);
    packed = decoder.readUint8();
    val.isPlatformDecoder = (packed >> 0) & 1 ? true : false;
    val.hasDecryptingDemuxerStream = (packed >> 1) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  PipelineDecoderInfo.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PipelineDecoderInfo.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.String, val.decoderName);
    packed = 0;
    packed |= (val.isPlatformDecoder & 1) << 0
    packed |= (val.hasDecryptingDemuxerStream & 1) << 1
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function Status(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Status.prototype.initDefaults_ = function() {
    this.code = 0;
    this.message = null;
    this.frames = null;
    this.causes = null;
    this.data = null;
  };
  Status.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Status.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 56}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Status.code
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, StatusCode);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Status.message
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 8, true)
    if (err !== validator.validationError.NONE)
        return err;


    // validate Status.frames
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 16, 16, values$.Value, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Status.causes
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 24, 8, new codec.PointerTo(Status), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Status.data
    err = messageValidator.validateUnion(offset + codec.kStructHeaderSize + 32, values$.Value, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Status.encodedSize = codec.kStructHeaderSize + 48;

  Status.decode = function(decoder) {
    var packed;
    var val = new Status();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.code =
        decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.message =
        decoder.decodeStruct(codec.NullableString);
    val.frames =
        decoder.decodeArrayPointer(values$.Value);
    val.causes =
        decoder.decodeArrayPointer(new codec.PointerTo(Status));
    val.data =
        decoder.decodeStruct(values$.Value);
    return val;
  };

  Status.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Status.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.code);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.NullableString, val.message);
    encoder.encodeArrayPointer(values$.Value, val.frames);
    encoder.encodeArrayPointer(new codec.PointerTo(Status), val.causes);
    encoder.encodeStruct(values$.Value, val.data);
  };

  function VideoFrameData(value) {
    this.initDefault_();
    this.initValue_(value);
  }


  VideoFrameData.Tags = {
    eosData: 0,
    sharedBufferData: 1,
    dmabufData: 2,
    gpuMemoryBufferData: 3,
    mailboxData: 4,
  };

  VideoFrameData.prototype.initDefault_ = function() {
    this.$data = null;
    this.$tag = undefined;
  }

  VideoFrameData.prototype.initValue_ = function(value) {
    if (value == undefined) {
      return;
    }

    var keys = Object.keys(value);
    if (keys.length == 0) {
      return;
    }

    if (keys.length > 1) {
      throw new TypeError("You may set only one member on a union.");
    }

    var fields = [
        "eosData",
        "sharedBufferData",
        "dmabufData",
        "gpuMemoryBufferData",
        "mailboxData",
    ];

    if (fields.indexOf(keys[0]) < 0) {
      throw new ReferenceError(keys[0] + " is not a VideoFrameData member.");

    }

    this[keys[0]] = value[keys[0]];
  }
  Object.defineProperty(VideoFrameData.prototype, "eosData", {
    get: function() {
      if (this.$tag != VideoFrameData.Tags.eosData) {
        throw new ReferenceError(
            "VideoFrameData.eosData is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = VideoFrameData.Tags.eosData;
      this.$data = value;
    }
  });
  Object.defineProperty(VideoFrameData.prototype, "sharedBufferData", {
    get: function() {
      if (this.$tag != VideoFrameData.Tags.sharedBufferData) {
        throw new ReferenceError(
            "VideoFrameData.sharedBufferData is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = VideoFrameData.Tags.sharedBufferData;
      this.$data = value;
    }
  });
  Object.defineProperty(VideoFrameData.prototype, "dmabufData", {
    get: function() {
      if (this.$tag != VideoFrameData.Tags.dmabufData) {
        throw new ReferenceError(
            "VideoFrameData.dmabufData is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = VideoFrameData.Tags.dmabufData;
      this.$data = value;
    }
  });
  Object.defineProperty(VideoFrameData.prototype, "gpuMemoryBufferData", {
    get: function() {
      if (this.$tag != VideoFrameData.Tags.gpuMemoryBufferData) {
        throw new ReferenceError(
            "VideoFrameData.gpuMemoryBufferData is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = VideoFrameData.Tags.gpuMemoryBufferData;
      this.$data = value;
    }
  });
  Object.defineProperty(VideoFrameData.prototype, "mailboxData", {
    get: function() {
      if (this.$tag != VideoFrameData.Tags.mailboxData) {
        throw new ReferenceError(
            "VideoFrameData.mailboxData is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = VideoFrameData.Tags.mailboxData;
      this.$data = value;
    }
  });


    VideoFrameData.encode = function(encoder, val) {
      if (val == null) {
        encoder.writeUint64(0);
        encoder.writeUint64(0);
        return;
      }
      if (val.$tag == undefined) {
        throw new TypeError("Cannot encode unions with an unknown member set.");
      }

      encoder.writeUint32(16);
      encoder.writeUint32(val.$tag);
      switch (val.$tag) {
        case VideoFrameData.Tags.eosData:
          encoder.encodeStructPointer(EosVideoFrameData, val.eosData);
          break;
        case VideoFrameData.Tags.sharedBufferData:
          encoder.encodeStructPointer(SharedBufferVideoFrameData, val.sharedBufferData);
          break;
        case VideoFrameData.Tags.dmabufData:
          encoder.encodeStructPointer(DmabufVideoFrameData, val.dmabufData);
          break;
        case VideoFrameData.Tags.gpuMemoryBufferData:
          encoder.encodeStructPointer(GpuMemoryBufferVideoFrameData, val.gpuMemoryBufferData);
          break;
        case VideoFrameData.Tags.mailboxData:
          encoder.encodeStructPointer(MailboxVideoFrameData, val.mailboxData);
          break;
      }
      encoder.align();
    };


    VideoFrameData.decode = function(decoder) {
      var size = decoder.readUint32();
      if (size == 0) {
        decoder.readUint32();
        decoder.readUint64();
        return null;
      }

      var result = new VideoFrameData();
      var tag = decoder.readUint32();
      switch (tag) {
        case VideoFrameData.Tags.eosData:
          result.eosData = decoder.decodeStructPointer(EosVideoFrameData);
          break;
        case VideoFrameData.Tags.sharedBufferData:
          result.sharedBufferData = decoder.decodeStructPointer(SharedBufferVideoFrameData);
          break;
        case VideoFrameData.Tags.dmabufData:
          result.dmabufData = decoder.decodeStructPointer(DmabufVideoFrameData);
          break;
        case VideoFrameData.Tags.gpuMemoryBufferData:
          result.gpuMemoryBufferData = decoder.decodeStructPointer(GpuMemoryBufferVideoFrameData);
          break;
        case VideoFrameData.Tags.mailboxData:
          result.mailboxData = decoder.decodeStructPointer(MailboxVideoFrameData);
          break;
      }
      decoder.align();

      return result;
    };


    VideoFrameData.validate = function(messageValidator, offset) {
      var size = messageValidator.decodeUnionSize(offset);
      if (size != 16) {
        return validator.validationError.INVALID_UNION_SIZE;
      }

      var tag = messageValidator.decodeUnionTag(offset);
      var data_offset = offset + 8;
      var err;
      switch (tag) {
        case VideoFrameData.Tags.eosData:
          

    // validate VideoFrameData.eosData
    err = messageValidator.validateStructPointer(data_offset, EosVideoFrameData, false);
    if (err !== validator.validationError.NONE)
        return err;
          break;
        case VideoFrameData.Tags.sharedBufferData:
          

    // validate VideoFrameData.sharedBufferData
    err = messageValidator.validateStructPointer(data_offset, SharedBufferVideoFrameData, false);
    if (err !== validator.validationError.NONE)
        return err;
          break;
        case VideoFrameData.Tags.dmabufData:
          

    // validate VideoFrameData.dmabufData
    err = messageValidator.validateStructPointer(data_offset, DmabufVideoFrameData, false);
    if (err !== validator.validationError.NONE)
        return err;
          break;
        case VideoFrameData.Tags.gpuMemoryBufferData:
          

    // validate VideoFrameData.gpuMemoryBufferData
    err = messageValidator.validateStructPointer(data_offset, GpuMemoryBufferVideoFrameData, false);
    if (err !== validator.validationError.NONE)
        return err;
          break;
        case VideoFrameData.Tags.mailboxData:
          

    // validate VideoFrameData.mailboxData
    err = messageValidator.validateStructPointer(data_offset, MailboxVideoFrameData, false);
    if (err !== validator.validationError.NONE)
        return err;
          break;
      }

      return validator.validationError.NONE;
    };

  VideoFrameData.encodedSize = 16;
  exports.AudioCodec = AudioCodec;
  exports.AudioCodecProfile = AudioCodecProfile;
  exports.BufferingState = BufferingState;
  exports.BufferingStateChangeReason = BufferingStateChangeReason;
  exports.ChannelLayout = ChannelLayout;
  exports.DecodeStatus = DecodeStatus;
  exports.StatusCode = StatusCode;
  exports.OutputDeviceStatus = OutputDeviceStatus;
  exports.PipelineStatus = PipelineStatus;
  exports.SampleFormat = SampleFormat;
  exports.VideoCodec = VideoCodec;
  exports.VideoCodecProfile = VideoCodecProfile;
  exports.VideoPixelFormat = VideoPixelFormat;
  exports.VideoRotation = VideoRotation;
  exports.CopyMode = CopyMode;
  exports.WaitingReason = WaitingReason;
  exports.WatchTimeKey = WatchTimeKey;
  exports.MediaContainerName = MediaContainerName;
  exports.MediaStatusState = MediaStatusState;
  exports.EncryptionScheme = EncryptionScheme;
  exports.MediaLogRecord = MediaLogRecord;
  exports.VideoTransformation = VideoTransformation;
  exports.EncryptionPattern = EncryptionPattern;
  exports.VideoColorSpace = VideoColorSpace;
  exports.AudioDecoderConfig = AudioDecoderConfig;
  exports.VideoDecoderConfig = VideoDecoderConfig;
  exports.SubsampleEntry = SubsampleEntry;
  exports.DecryptConfig = DecryptConfig;
  exports.DecoderBuffer = DecoderBuffer;
  exports.AudioBuffer = AudioBuffer;
  exports.AudioDataS16 = AudioDataS16;
  exports.VideoFrameMetadata = VideoFrameMetadata;
  exports.VideoFrame = VideoFrame;
  exports.EosVideoFrameData = EosVideoFrameData;
  exports.SharedBufferVideoFrameData = SharedBufferVideoFrameData;
  exports.DmabufVideoFrameData = DmabufVideoFrameData;
  exports.GpuMemoryBufferVideoFrameData = GpuMemoryBufferVideoFrameData;
  exports.MailboxVideoFrameData = MailboxVideoFrameData;
  exports.PipelineStatistics = PipelineStatistics;
  exports.PredictionFeatures = PredictionFeatures;
  exports.PredictionTargets = PredictionTargets;
  exports.PipelineDecoderInfo = PipelineDecoderInfo;
  exports.Status = Status;
  exports.VideoFrameData = VideoFrameData;
})();