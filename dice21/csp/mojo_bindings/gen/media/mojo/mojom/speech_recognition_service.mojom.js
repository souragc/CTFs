// media/mojo/mojom/speech_recognition_service.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'media/mojo/mojom/speech_recognition_service.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('media.mojom');
  var media_types$ =
      mojo.internal.exposeNamespace('media.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'media/mojo/mojom/media_types.mojom', 'media_types.mojom.js');
  }
  var file_path$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/file_path.mojom', '../../../mojo/public/mojom/base/file_path.mojom.js');
  }
  var time$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/time.mojom', '../../../mojo/public/mojom/base/time.mojom.js');
  }
  var url_loader_factory$ =
      mojo.internal.exposeNamespace('network.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'services/network/public/mojom/url_loader_factory.mojom', '../../../services/network/public/mojom/url_loader_factory.mojom.js');
  }



  function SpeechRecognitionResult(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionResult.prototype.initDefaults_ = function() {
    this.transcription = null;
    this.isFinal = false;
  };
  SpeechRecognitionResult.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionResult.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionResult.transcription
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  SpeechRecognitionResult.encodedSize = codec.kStructHeaderSize + 16;

  SpeechRecognitionResult.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionResult();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.transcription =
        decoder.decodeStruct(codec.String);
    packed = decoder.readUint8();
    val.isFinal = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  SpeechRecognitionResult.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionResult.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.String, val.transcription);
    packed = 0;
    packed |= (val.isFinal & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function SpeechRecognitionContext_BindRecognizer_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionContext_BindRecognizer_Params.prototype.initDefaults_ = function() {
    this.receiver = new bindings.InterfaceRequest();
    this.client = new SpeechRecognitionRecognizerClientPtr();
  };
  SpeechRecognitionContext_BindRecognizer_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionContext_BindRecognizer_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionContext_BindRecognizer_Params.receiver
    err = messageValidator.validateInterfaceRequest(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionContext_BindRecognizer_Params.client
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 4, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionContext_BindRecognizer_Params.encodedSize = codec.kStructHeaderSize + 16;

  SpeechRecognitionContext_BindRecognizer_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionContext_BindRecognizer_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.receiver =
        decoder.decodeStruct(codec.InterfaceRequest);
    val.client =
        decoder.decodeStruct(new codec.Interface(SpeechRecognitionRecognizerClientPtr));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  SpeechRecognitionContext_BindRecognizer_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionContext_BindRecognizer_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.InterfaceRequest, val.receiver);
    encoder.encodeStruct(new codec.Interface(SpeechRecognitionRecognizerClientPtr), val.client);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function SpeechRecognitionContext_BindRecognizer_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionContext_BindRecognizer_ResponseParams.prototype.initDefaults_ = function() {
    this.isMultichannelSupported = false;
  };
  SpeechRecognitionContext_BindRecognizer_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionContext_BindRecognizer_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  SpeechRecognitionContext_BindRecognizer_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  SpeechRecognitionContext_BindRecognizer_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionContext_BindRecognizer_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.isMultichannelSupported = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  SpeechRecognitionContext_BindRecognizer_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionContext_BindRecognizer_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.isMultichannelSupported & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function SpeechRecognitionService_BindContext_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionService_BindContext_Params.prototype.initDefaults_ = function() {
    this.context = new bindings.InterfaceRequest();
  };
  SpeechRecognitionService_BindContext_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionService_BindContext_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionService_BindContext_Params.context
    err = messageValidator.validateInterfaceRequest(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionService_BindContext_Params.encodedSize = codec.kStructHeaderSize + 8;

  SpeechRecognitionService_BindContext_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionService_BindContext_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.context =
        decoder.decodeStruct(codec.InterfaceRequest);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  SpeechRecognitionService_BindContext_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionService_BindContext_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.InterfaceRequest, val.context);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function SpeechRecognitionService_SetUrlLoaderFactory_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionService_SetUrlLoaderFactory_Params.prototype.initDefaults_ = function() {
    this.urlLoaderFactory = new url_loader_factory$.URLLoaderFactoryPtr();
  };
  SpeechRecognitionService_SetUrlLoaderFactory_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionService_SetUrlLoaderFactory_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionService_SetUrlLoaderFactory_Params.urlLoaderFactory
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 0, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionService_SetUrlLoaderFactory_Params.encodedSize = codec.kStructHeaderSize + 8;

  SpeechRecognitionService_SetUrlLoaderFactory_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionService_SetUrlLoaderFactory_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.urlLoaderFactory =
        decoder.decodeStruct(new codec.Interface(url_loader_factory$.URLLoaderFactoryPtr));
    return val;
  };

  SpeechRecognitionService_SetUrlLoaderFactory_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionService_SetUrlLoaderFactory_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(new codec.Interface(url_loader_factory$.URLLoaderFactoryPtr), val.urlLoaderFactory);
  };
  function SpeechRecognitionService_SetSodaPath_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionService_SetSodaPath_Params.prototype.initDefaults_ = function() {
    this.binaryPath = null;
    this.configPath = null;
  };
  SpeechRecognitionService_SetSodaPath_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionService_SetSodaPath_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionService_SetSodaPath_Params.binaryPath
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, file_path$.FilePath, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionService_SetSodaPath_Params.configPath
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, file_path$.FilePath, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionService_SetSodaPath_Params.encodedSize = codec.kStructHeaderSize + 16;

  SpeechRecognitionService_SetSodaPath_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionService_SetSodaPath_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.binaryPath =
        decoder.decodeStructPointer(file_path$.FilePath);
    val.configPath =
        decoder.decodeStructPointer(file_path$.FilePath);
    return val;
  };

  SpeechRecognitionService_SetSodaPath_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionService_SetSodaPath_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(file_path$.FilePath, val.binaryPath);
    encoder.encodeStructPointer(file_path$.FilePath, val.configPath);
  };
  function SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params.prototype.initDefaults_ = function() {
    this.client = new SpeechRecognitionServiceClientPtr();
  };
  SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params.client
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 0, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params.encodedSize = codec.kStructHeaderSize + 8;

  SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.client =
        decoder.decodeStruct(new codec.Interface(SpeechRecognitionServiceClientPtr));
    return val;
  };

  SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(new codec.Interface(SpeechRecognitionServiceClientPtr), val.client);
  };
  function SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params.prototype.initDefaults_ = function() {
  };
  SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params.encodedSize = codec.kStructHeaderSize + 0;

  SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params.prototype.initDefaults_ = function() {
    this.buffer = null;
  };
  SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params.buffer
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, media_types$.AudioDataS16, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params.encodedSize = codec.kStructHeaderSize + 8;

  SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.buffer =
        decoder.decodeStructPointer(media_types$.AudioDataS16);
    return val;
  };

  SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(media_types$.AudioDataS16, val.buffer);
  };
  function SpeechRecognitionRecognizer_OnCaptionBubbleClosed_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionRecognizer_OnCaptionBubbleClosed_Params.prototype.initDefaults_ = function() {
  };
  SpeechRecognitionRecognizer_OnCaptionBubbleClosed_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionRecognizer_OnCaptionBubbleClosed_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionRecognizer_OnCaptionBubbleClosed_Params.encodedSize = codec.kStructHeaderSize + 0;

  SpeechRecognitionRecognizer_OnCaptionBubbleClosed_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionRecognizer_OnCaptionBubbleClosed_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  SpeechRecognitionRecognizer_OnCaptionBubbleClosed_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionRecognizer_OnCaptionBubbleClosed_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function SpeechRecognitionRecognizer_AudioReceivedAfterBubbleClosed_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionRecognizer_AudioReceivedAfterBubbleClosed_Params.prototype.initDefaults_ = function() {
    this.duration = null;
  };
  SpeechRecognitionRecognizer_AudioReceivedAfterBubbleClosed_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionRecognizer_AudioReceivedAfterBubbleClosed_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionRecognizer_AudioReceivedAfterBubbleClosed_Params.duration
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionRecognizer_AudioReceivedAfterBubbleClosed_Params.encodedSize = codec.kStructHeaderSize + 8;

  SpeechRecognitionRecognizer_AudioReceivedAfterBubbleClosed_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionRecognizer_AudioReceivedAfterBubbleClosed_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.duration =
        decoder.decodeStructPointer(time$.TimeDelta);
    return val;
  };

  SpeechRecognitionRecognizer_AudioReceivedAfterBubbleClosed_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionRecognizer_AudioReceivedAfterBubbleClosed_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(time$.TimeDelta, val.duration);
  };
  function SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params.prototype.initDefaults_ = function() {
    this.result = null;
  };
  SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params.result
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, SpeechRecognitionResult, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params.encodedSize = codec.kStructHeaderSize + 8;

  SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.result =
        decoder.decodeStructPointer(SpeechRecognitionResult);
    return val;
  };

  SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(SpeechRecognitionResult, val.result);
  };
  function SpeechRecognitionAvailabilityObserver_SpeechRecognitionAvailabilityChanged_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionAvailabilityObserver_SpeechRecognitionAvailabilityChanged_Params.prototype.initDefaults_ = function() {
    this.isSpeechRecognitionAvailable = false;
  };
  SpeechRecognitionAvailabilityObserver_SpeechRecognitionAvailabilityChanged_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionAvailabilityObserver_SpeechRecognitionAvailabilityChanged_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  SpeechRecognitionAvailabilityObserver_SpeechRecognitionAvailabilityChanged_Params.encodedSize = codec.kStructHeaderSize + 8;

  SpeechRecognitionAvailabilityObserver_SpeechRecognitionAvailabilityChanged_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionAvailabilityObserver_SpeechRecognitionAvailabilityChanged_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.isSpeechRecognitionAvailable = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  SpeechRecognitionAvailabilityObserver_SpeechRecognitionAvailabilityChanged_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionAvailabilityObserver_SpeechRecognitionAvailabilityChanged_Params.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.isSpeechRecognitionAvailable & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionAvailabilityObserver_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionAvailabilityObserver_Params.prototype.initDefaults_ = function() {
    this.observer = new SpeechRecognitionAvailabilityObserverPtr();
  };
  SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionAvailabilityObserver_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionAvailabilityObserver_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionAvailabilityObserver_Params.observer
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 0, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionAvailabilityObserver_Params.encodedSize = codec.kStructHeaderSize + 8;

  SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionAvailabilityObserver_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionAvailabilityObserver_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.observer =
        decoder.decodeStruct(new codec.Interface(SpeechRecognitionAvailabilityObserverPtr));
    return val;
  };

  SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionAvailabilityObserver_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionAvailabilityObserver_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(new codec.Interface(SpeechRecognitionAvailabilityObserverPtr), val.observer);
  };
  var kSpeechRecognitionContext_BindRecognizer_Name = 1004388358;

  function SpeechRecognitionContextPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(SpeechRecognitionContext,
                                                   handleOrPtrInfo);
  }

  function SpeechRecognitionContextAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        SpeechRecognitionContext, associatedInterfacePtrInfo);
  }

  SpeechRecognitionContextAssociatedPtr.prototype =
      Object.create(SpeechRecognitionContextPtr.prototype);
  SpeechRecognitionContextAssociatedPtr.prototype.constructor =
      SpeechRecognitionContextAssociatedPtr;

  function SpeechRecognitionContextProxy(receiver) {
    this.receiver_ = receiver;
  }
  SpeechRecognitionContextPtr.prototype.bindRecognizer = function() {
    return SpeechRecognitionContextProxy.prototype.bindRecognizer
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionContextProxy.prototype.bindRecognizer = function(receiver, client) {
    var params_ = new SpeechRecognitionContext_BindRecognizer_Params();
    params_.receiver = receiver;
    params_.client = client;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kSpeechRecognitionContext_BindRecognizer_Name,
          codec.align(SpeechRecognitionContext_BindRecognizer_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(SpeechRecognitionContext_BindRecognizer_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(SpeechRecognitionContext_BindRecognizer_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function SpeechRecognitionContextStub(delegate) {
    this.delegate_ = delegate;
  }
  SpeechRecognitionContextStub.prototype.bindRecognizer = function(receiver, client) {
    return this.delegate_ && this.delegate_.bindRecognizer && this.delegate_.bindRecognizer(receiver, client);
  }

  SpeechRecognitionContextStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  SpeechRecognitionContextStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kSpeechRecognitionContext_BindRecognizer_Name:
      var params = reader.decodeStruct(SpeechRecognitionContext_BindRecognizer_Params);
      this.bindRecognizer(params.receiver, params.client).then(function(response) {
        var responseParams =
            new SpeechRecognitionContext_BindRecognizer_ResponseParams();
        responseParams.isMultichannelSupported = response.isMultichannelSupported;
        var builder = new codec.MessageV1Builder(
            kSpeechRecognitionContext_BindRecognizer_Name,
            codec.align(SpeechRecognitionContext_BindRecognizer_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(SpeechRecognitionContext_BindRecognizer_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateSpeechRecognitionContextRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kSpeechRecognitionContext_BindRecognizer_Name:
        if (message.expectsResponse())
          paramsClass = SpeechRecognitionContext_BindRecognizer_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateSpeechRecognitionContextResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kSpeechRecognitionContext_BindRecognizer_Name:
        if (message.isResponse())
          paramsClass = SpeechRecognitionContext_BindRecognizer_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var SpeechRecognitionContext = {
    name: 'media.mojom.SpeechRecognitionContext',
    kVersion: 0,
    ptrClass: SpeechRecognitionContextPtr,
    proxyClass: SpeechRecognitionContextProxy,
    stubClass: SpeechRecognitionContextStub,
    validateRequest: validateSpeechRecognitionContextRequest,
    validateResponse: validateSpeechRecognitionContextResponse,
  };
  SpeechRecognitionContextStub.prototype.validator = validateSpeechRecognitionContextRequest;
  SpeechRecognitionContextProxy.prototype.validator = validateSpeechRecognitionContextResponse;
  var kSpeechRecognitionService_BindContext_Name = 1755982575;
  var kSpeechRecognitionService_SetUrlLoaderFactory_Name = 1136546879;
  var kSpeechRecognitionService_SetSodaPath_Name = 434259687;
  var kSpeechRecognitionService_BindSpeechRecognitionServiceClient_Name = 1737184478;

  function SpeechRecognitionServicePtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(SpeechRecognitionService,
                                                   handleOrPtrInfo);
  }

  function SpeechRecognitionServiceAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        SpeechRecognitionService, associatedInterfacePtrInfo);
  }

  SpeechRecognitionServiceAssociatedPtr.prototype =
      Object.create(SpeechRecognitionServicePtr.prototype);
  SpeechRecognitionServiceAssociatedPtr.prototype.constructor =
      SpeechRecognitionServiceAssociatedPtr;

  function SpeechRecognitionServiceProxy(receiver) {
    this.receiver_ = receiver;
  }
  SpeechRecognitionServicePtr.prototype.bindContext = function() {
    return SpeechRecognitionServiceProxy.prototype.bindContext
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionServiceProxy.prototype.bindContext = function(context) {
    var params_ = new SpeechRecognitionService_BindContext_Params();
    params_.context = context;
    var builder = new codec.MessageV0Builder(
        kSpeechRecognitionService_BindContext_Name,
        codec.align(SpeechRecognitionService_BindContext_Params.encodedSize));
    builder.encodeStruct(SpeechRecognitionService_BindContext_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  SpeechRecognitionServicePtr.prototype.setUrlLoaderFactory = function() {
    return SpeechRecognitionServiceProxy.prototype.setUrlLoaderFactory
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionServiceProxy.prototype.setUrlLoaderFactory = function(urlLoaderFactory) {
    var params_ = new SpeechRecognitionService_SetUrlLoaderFactory_Params();
    params_.urlLoaderFactory = urlLoaderFactory;
    var builder = new codec.MessageV0Builder(
        kSpeechRecognitionService_SetUrlLoaderFactory_Name,
        codec.align(SpeechRecognitionService_SetUrlLoaderFactory_Params.encodedSize));
    builder.encodeStruct(SpeechRecognitionService_SetUrlLoaderFactory_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  SpeechRecognitionServicePtr.prototype.setSodaPath = function() {
    return SpeechRecognitionServiceProxy.prototype.setSodaPath
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionServiceProxy.prototype.setSodaPath = function(binaryPath, configPath) {
    var params_ = new SpeechRecognitionService_SetSodaPath_Params();
    params_.binaryPath = binaryPath;
    params_.configPath = configPath;
    var builder = new codec.MessageV0Builder(
        kSpeechRecognitionService_SetSodaPath_Name,
        codec.align(SpeechRecognitionService_SetSodaPath_Params.encodedSize));
    builder.encodeStruct(SpeechRecognitionService_SetSodaPath_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  SpeechRecognitionServicePtr.prototype.bindSpeechRecognitionServiceClient = function() {
    return SpeechRecognitionServiceProxy.prototype.bindSpeechRecognitionServiceClient
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionServiceProxy.prototype.bindSpeechRecognitionServiceClient = function(client) {
    var params_ = new SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params();
    params_.client = client;
    var builder = new codec.MessageV0Builder(
        kSpeechRecognitionService_BindSpeechRecognitionServiceClient_Name,
        codec.align(SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params.encodedSize));
    builder.encodeStruct(SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function SpeechRecognitionServiceStub(delegate) {
    this.delegate_ = delegate;
  }
  SpeechRecognitionServiceStub.prototype.bindContext = function(context) {
    return this.delegate_ && this.delegate_.bindContext && this.delegate_.bindContext(context);
  }
  SpeechRecognitionServiceStub.prototype.setUrlLoaderFactory = function(urlLoaderFactory) {
    return this.delegate_ && this.delegate_.setUrlLoaderFactory && this.delegate_.setUrlLoaderFactory(urlLoaderFactory);
  }
  SpeechRecognitionServiceStub.prototype.setSodaPath = function(binaryPath, configPath) {
    return this.delegate_ && this.delegate_.setSodaPath && this.delegate_.setSodaPath(binaryPath, configPath);
  }
  SpeechRecognitionServiceStub.prototype.bindSpeechRecognitionServiceClient = function(client) {
    return this.delegate_ && this.delegate_.bindSpeechRecognitionServiceClient && this.delegate_.bindSpeechRecognitionServiceClient(client);
  }

  SpeechRecognitionServiceStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kSpeechRecognitionService_BindContext_Name:
      var params = reader.decodeStruct(SpeechRecognitionService_BindContext_Params);
      this.bindContext(params.context);
      return true;
    case kSpeechRecognitionService_SetUrlLoaderFactory_Name:
      var params = reader.decodeStruct(SpeechRecognitionService_SetUrlLoaderFactory_Params);
      this.setUrlLoaderFactory(params.urlLoaderFactory);
      return true;
    case kSpeechRecognitionService_SetSodaPath_Name:
      var params = reader.decodeStruct(SpeechRecognitionService_SetSodaPath_Params);
      this.setSodaPath(params.binaryPath, params.configPath);
      return true;
    case kSpeechRecognitionService_BindSpeechRecognitionServiceClient_Name:
      var params = reader.decodeStruct(SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params);
      this.bindSpeechRecognitionServiceClient(params.client);
      return true;
    default:
      return false;
    }
  };

  SpeechRecognitionServiceStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateSpeechRecognitionServiceRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kSpeechRecognitionService_BindContext_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = SpeechRecognitionService_BindContext_Params;
      break;
      case kSpeechRecognitionService_SetUrlLoaderFactory_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = SpeechRecognitionService_SetUrlLoaderFactory_Params;
      break;
      case kSpeechRecognitionService_SetSodaPath_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = SpeechRecognitionService_SetSodaPath_Params;
      break;
      case kSpeechRecognitionService_BindSpeechRecognitionServiceClient_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateSpeechRecognitionServiceResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var SpeechRecognitionService = {
    name: 'media.mojom.SpeechRecognitionService',
    kVersion: 0,
    ptrClass: SpeechRecognitionServicePtr,
    proxyClass: SpeechRecognitionServiceProxy,
    stubClass: SpeechRecognitionServiceStub,
    validateRequest: validateSpeechRecognitionServiceRequest,
    validateResponse: null,
  };
  SpeechRecognitionServiceStub.prototype.validator = validateSpeechRecognitionServiceRequest;
  SpeechRecognitionServiceProxy.prototype.validator = null;
  var kSpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Name = 930413514;

  function SpeechRecognitionServiceClientPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(SpeechRecognitionServiceClient,
                                                   handleOrPtrInfo);
  }

  function SpeechRecognitionServiceClientAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        SpeechRecognitionServiceClient, associatedInterfacePtrInfo);
  }

  SpeechRecognitionServiceClientAssociatedPtr.prototype =
      Object.create(SpeechRecognitionServiceClientPtr.prototype);
  SpeechRecognitionServiceClientAssociatedPtr.prototype.constructor =
      SpeechRecognitionServiceClientAssociatedPtr;

  function SpeechRecognitionServiceClientProxy(receiver) {
    this.receiver_ = receiver;
  }
  SpeechRecognitionServiceClientPtr.prototype.onNetworkServiceDisconnect = function() {
    return SpeechRecognitionServiceClientProxy.prototype.onNetworkServiceDisconnect
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionServiceClientProxy.prototype.onNetworkServiceDisconnect = function() {
    var params_ = new SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params();
    var builder = new codec.MessageV0Builder(
        kSpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Name,
        codec.align(SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params.encodedSize));
    builder.encodeStruct(SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function SpeechRecognitionServiceClientStub(delegate) {
    this.delegate_ = delegate;
  }
  SpeechRecognitionServiceClientStub.prototype.onNetworkServiceDisconnect = function() {
    return this.delegate_ && this.delegate_.onNetworkServiceDisconnect && this.delegate_.onNetworkServiceDisconnect();
  }

  SpeechRecognitionServiceClientStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kSpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Name:
      var params = reader.decodeStruct(SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params);
      this.onNetworkServiceDisconnect();
      return true;
    default:
      return false;
    }
  };

  SpeechRecognitionServiceClientStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateSpeechRecognitionServiceClientRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kSpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateSpeechRecognitionServiceClientResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var SpeechRecognitionServiceClient = {
    name: 'media.mojom.SpeechRecognitionServiceClient',
    kVersion: 0,
    ptrClass: SpeechRecognitionServiceClientPtr,
    proxyClass: SpeechRecognitionServiceClientProxy,
    stubClass: SpeechRecognitionServiceClientStub,
    validateRequest: validateSpeechRecognitionServiceClientRequest,
    validateResponse: null,
  };
  SpeechRecognitionServiceClientStub.prototype.validator = validateSpeechRecognitionServiceClientRequest;
  SpeechRecognitionServiceClientProxy.prototype.validator = null;
  var kSpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Name = 379470772;
  var kSpeechRecognitionRecognizer_OnCaptionBubbleClosed_Name = 1224554452;
  var kSpeechRecognitionRecognizer_AudioReceivedAfterBubbleClosed_Name = 1521341890;

  function SpeechRecognitionRecognizerPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(SpeechRecognitionRecognizer,
                                                   handleOrPtrInfo);
  }

  function SpeechRecognitionRecognizerAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        SpeechRecognitionRecognizer, associatedInterfacePtrInfo);
  }

  SpeechRecognitionRecognizerAssociatedPtr.prototype =
      Object.create(SpeechRecognitionRecognizerPtr.prototype);
  SpeechRecognitionRecognizerAssociatedPtr.prototype.constructor =
      SpeechRecognitionRecognizerAssociatedPtr;

  function SpeechRecognitionRecognizerProxy(receiver) {
    this.receiver_ = receiver;
  }
  SpeechRecognitionRecognizerPtr.prototype.sendAudioToSpeechRecognitionService = function() {
    return SpeechRecognitionRecognizerProxy.prototype.sendAudioToSpeechRecognitionService
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionRecognizerProxy.prototype.sendAudioToSpeechRecognitionService = function(buffer) {
    var params_ = new SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params();
    params_.buffer = buffer;
    var builder = new codec.MessageV0Builder(
        kSpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Name,
        codec.align(SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params.encodedSize));
    builder.encodeStruct(SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  SpeechRecognitionRecognizerPtr.prototype.onCaptionBubbleClosed = function() {
    return SpeechRecognitionRecognizerProxy.prototype.onCaptionBubbleClosed
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionRecognizerProxy.prototype.onCaptionBubbleClosed = function() {
    var params_ = new SpeechRecognitionRecognizer_OnCaptionBubbleClosed_Params();
    var builder = new codec.MessageV0Builder(
        kSpeechRecognitionRecognizer_OnCaptionBubbleClosed_Name,
        codec.align(SpeechRecognitionRecognizer_OnCaptionBubbleClosed_Params.encodedSize));
    builder.encodeStruct(SpeechRecognitionRecognizer_OnCaptionBubbleClosed_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  SpeechRecognitionRecognizerPtr.prototype.audioReceivedAfterBubbleClosed = function() {
    return SpeechRecognitionRecognizerProxy.prototype.audioReceivedAfterBubbleClosed
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionRecognizerProxy.prototype.audioReceivedAfterBubbleClosed = function(duration) {
    var params_ = new SpeechRecognitionRecognizer_AudioReceivedAfterBubbleClosed_Params();
    params_.duration = duration;
    var builder = new codec.MessageV0Builder(
        kSpeechRecognitionRecognizer_AudioReceivedAfterBubbleClosed_Name,
        codec.align(SpeechRecognitionRecognizer_AudioReceivedAfterBubbleClosed_Params.encodedSize));
    builder.encodeStruct(SpeechRecognitionRecognizer_AudioReceivedAfterBubbleClosed_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function SpeechRecognitionRecognizerStub(delegate) {
    this.delegate_ = delegate;
  }
  SpeechRecognitionRecognizerStub.prototype.sendAudioToSpeechRecognitionService = function(buffer) {
    return this.delegate_ && this.delegate_.sendAudioToSpeechRecognitionService && this.delegate_.sendAudioToSpeechRecognitionService(buffer);
  }
  SpeechRecognitionRecognizerStub.prototype.onCaptionBubbleClosed = function() {
    return this.delegate_ && this.delegate_.onCaptionBubbleClosed && this.delegate_.onCaptionBubbleClosed();
  }
  SpeechRecognitionRecognizerStub.prototype.audioReceivedAfterBubbleClosed = function(duration) {
    return this.delegate_ && this.delegate_.audioReceivedAfterBubbleClosed && this.delegate_.audioReceivedAfterBubbleClosed(duration);
  }

  SpeechRecognitionRecognizerStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kSpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Name:
      var params = reader.decodeStruct(SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params);
      this.sendAudioToSpeechRecognitionService(params.buffer);
      return true;
    case kSpeechRecognitionRecognizer_OnCaptionBubbleClosed_Name:
      var params = reader.decodeStruct(SpeechRecognitionRecognizer_OnCaptionBubbleClosed_Params);
      this.onCaptionBubbleClosed();
      return true;
    case kSpeechRecognitionRecognizer_AudioReceivedAfterBubbleClosed_Name:
      var params = reader.decodeStruct(SpeechRecognitionRecognizer_AudioReceivedAfterBubbleClosed_Params);
      this.audioReceivedAfterBubbleClosed(params.duration);
      return true;
    default:
      return false;
    }
  };

  SpeechRecognitionRecognizerStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateSpeechRecognitionRecognizerRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kSpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params;
      break;
      case kSpeechRecognitionRecognizer_OnCaptionBubbleClosed_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = SpeechRecognitionRecognizer_OnCaptionBubbleClosed_Params;
      break;
      case kSpeechRecognitionRecognizer_AudioReceivedAfterBubbleClosed_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = SpeechRecognitionRecognizer_AudioReceivedAfterBubbleClosed_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateSpeechRecognitionRecognizerResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var SpeechRecognitionRecognizer = {
    name: 'media.mojom.SpeechRecognitionRecognizer',
    kVersion: 0,
    ptrClass: SpeechRecognitionRecognizerPtr,
    proxyClass: SpeechRecognitionRecognizerProxy,
    stubClass: SpeechRecognitionRecognizerStub,
    validateRequest: validateSpeechRecognitionRecognizerRequest,
    validateResponse: null,
  };
  SpeechRecognitionRecognizerStub.prototype.validator = validateSpeechRecognitionRecognizerRequest;
  SpeechRecognitionRecognizerProxy.prototype.validator = null;
  var kSpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Name = 1481175983;

  function SpeechRecognitionRecognizerClientPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(SpeechRecognitionRecognizerClient,
                                                   handleOrPtrInfo);
  }

  function SpeechRecognitionRecognizerClientAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        SpeechRecognitionRecognizerClient, associatedInterfacePtrInfo);
  }

  SpeechRecognitionRecognizerClientAssociatedPtr.prototype =
      Object.create(SpeechRecognitionRecognizerClientPtr.prototype);
  SpeechRecognitionRecognizerClientAssociatedPtr.prototype.constructor =
      SpeechRecognitionRecognizerClientAssociatedPtr;

  function SpeechRecognitionRecognizerClientProxy(receiver) {
    this.receiver_ = receiver;
  }
  SpeechRecognitionRecognizerClientPtr.prototype.onSpeechRecognitionRecognitionEvent = function() {
    return SpeechRecognitionRecognizerClientProxy.prototype.onSpeechRecognitionRecognitionEvent
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionRecognizerClientProxy.prototype.onSpeechRecognitionRecognitionEvent = function(result) {
    var params_ = new SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params();
    params_.result = result;
    var builder = new codec.MessageV0Builder(
        kSpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Name,
        codec.align(SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params.encodedSize));
    builder.encodeStruct(SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function SpeechRecognitionRecognizerClientStub(delegate) {
    this.delegate_ = delegate;
  }
  SpeechRecognitionRecognizerClientStub.prototype.onSpeechRecognitionRecognitionEvent = function(result) {
    return this.delegate_ && this.delegate_.onSpeechRecognitionRecognitionEvent && this.delegate_.onSpeechRecognitionRecognitionEvent(result);
  }

  SpeechRecognitionRecognizerClientStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kSpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Name:
      var params = reader.decodeStruct(SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params);
      this.onSpeechRecognitionRecognitionEvent(params.result);
      return true;
    default:
      return false;
    }
  };

  SpeechRecognitionRecognizerClientStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateSpeechRecognitionRecognizerClientRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kSpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateSpeechRecognitionRecognizerClientResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var SpeechRecognitionRecognizerClient = {
    name: 'media.mojom.SpeechRecognitionRecognizerClient',
    kVersion: 0,
    ptrClass: SpeechRecognitionRecognizerClientPtr,
    proxyClass: SpeechRecognitionRecognizerClientProxy,
    stubClass: SpeechRecognitionRecognizerClientStub,
    validateRequest: validateSpeechRecognitionRecognizerClientRequest,
    validateResponse: null,
  };
  SpeechRecognitionRecognizerClientStub.prototype.validator = validateSpeechRecognitionRecognizerClientRequest;
  SpeechRecognitionRecognizerClientProxy.prototype.validator = null;
  var kSpeechRecognitionAvailabilityObserver_SpeechRecognitionAvailabilityChanged_Name = 1837592052;

  function SpeechRecognitionAvailabilityObserverPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(SpeechRecognitionAvailabilityObserver,
                                                   handleOrPtrInfo);
  }

  function SpeechRecognitionAvailabilityObserverAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        SpeechRecognitionAvailabilityObserver, associatedInterfacePtrInfo);
  }

  SpeechRecognitionAvailabilityObserverAssociatedPtr.prototype =
      Object.create(SpeechRecognitionAvailabilityObserverPtr.prototype);
  SpeechRecognitionAvailabilityObserverAssociatedPtr.prototype.constructor =
      SpeechRecognitionAvailabilityObserverAssociatedPtr;

  function SpeechRecognitionAvailabilityObserverProxy(receiver) {
    this.receiver_ = receiver;
  }
  SpeechRecognitionAvailabilityObserverPtr.prototype.speechRecognitionAvailabilityChanged = function() {
    return SpeechRecognitionAvailabilityObserverProxy.prototype.speechRecognitionAvailabilityChanged
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionAvailabilityObserverProxy.prototype.speechRecognitionAvailabilityChanged = function(isSpeechRecognitionAvailable) {
    var params_ = new SpeechRecognitionAvailabilityObserver_SpeechRecognitionAvailabilityChanged_Params();
    params_.isSpeechRecognitionAvailable = isSpeechRecognitionAvailable;
    var builder = new codec.MessageV0Builder(
        kSpeechRecognitionAvailabilityObserver_SpeechRecognitionAvailabilityChanged_Name,
        codec.align(SpeechRecognitionAvailabilityObserver_SpeechRecognitionAvailabilityChanged_Params.encodedSize));
    builder.encodeStruct(SpeechRecognitionAvailabilityObserver_SpeechRecognitionAvailabilityChanged_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function SpeechRecognitionAvailabilityObserverStub(delegate) {
    this.delegate_ = delegate;
  }
  SpeechRecognitionAvailabilityObserverStub.prototype.speechRecognitionAvailabilityChanged = function(isSpeechRecognitionAvailable) {
    return this.delegate_ && this.delegate_.speechRecognitionAvailabilityChanged && this.delegate_.speechRecognitionAvailabilityChanged(isSpeechRecognitionAvailable);
  }

  SpeechRecognitionAvailabilityObserverStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kSpeechRecognitionAvailabilityObserver_SpeechRecognitionAvailabilityChanged_Name:
      var params = reader.decodeStruct(SpeechRecognitionAvailabilityObserver_SpeechRecognitionAvailabilityChanged_Params);
      this.speechRecognitionAvailabilityChanged(params.isSpeechRecognitionAvailable);
      return true;
    default:
      return false;
    }
  };

  SpeechRecognitionAvailabilityObserverStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateSpeechRecognitionAvailabilityObserverRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kSpeechRecognitionAvailabilityObserver_SpeechRecognitionAvailabilityChanged_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = SpeechRecognitionAvailabilityObserver_SpeechRecognitionAvailabilityChanged_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateSpeechRecognitionAvailabilityObserverResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var SpeechRecognitionAvailabilityObserver = {
    name: 'media.mojom.SpeechRecognitionAvailabilityObserver',
    kVersion: 0,
    ptrClass: SpeechRecognitionAvailabilityObserverPtr,
    proxyClass: SpeechRecognitionAvailabilityObserverProxy,
    stubClass: SpeechRecognitionAvailabilityObserverStub,
    validateRequest: validateSpeechRecognitionAvailabilityObserverRequest,
    validateResponse: null,
  };
  SpeechRecognitionAvailabilityObserverStub.prototype.validator = validateSpeechRecognitionAvailabilityObserverRequest;
  SpeechRecognitionAvailabilityObserverProxy.prototype.validator = null;
  var kSpeechRecognitionClientBrowserInterface_BindSpeechRecognitionAvailabilityObserver_Name = 1963919302;

  function SpeechRecognitionClientBrowserInterfacePtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(SpeechRecognitionClientBrowserInterface,
                                                   handleOrPtrInfo);
  }

  function SpeechRecognitionClientBrowserInterfaceAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        SpeechRecognitionClientBrowserInterface, associatedInterfacePtrInfo);
  }

  SpeechRecognitionClientBrowserInterfaceAssociatedPtr.prototype =
      Object.create(SpeechRecognitionClientBrowserInterfacePtr.prototype);
  SpeechRecognitionClientBrowserInterfaceAssociatedPtr.prototype.constructor =
      SpeechRecognitionClientBrowserInterfaceAssociatedPtr;

  function SpeechRecognitionClientBrowserInterfaceProxy(receiver) {
    this.receiver_ = receiver;
  }
  SpeechRecognitionClientBrowserInterfacePtr.prototype.bindSpeechRecognitionAvailabilityObserver = function() {
    return SpeechRecognitionClientBrowserInterfaceProxy.prototype.bindSpeechRecognitionAvailabilityObserver
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionClientBrowserInterfaceProxy.prototype.bindSpeechRecognitionAvailabilityObserver = function(observer) {
    var params_ = new SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionAvailabilityObserver_Params();
    params_.observer = observer;
    var builder = new codec.MessageV0Builder(
        kSpeechRecognitionClientBrowserInterface_BindSpeechRecognitionAvailabilityObserver_Name,
        codec.align(SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionAvailabilityObserver_Params.encodedSize));
    builder.encodeStruct(SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionAvailabilityObserver_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function SpeechRecognitionClientBrowserInterfaceStub(delegate) {
    this.delegate_ = delegate;
  }
  SpeechRecognitionClientBrowserInterfaceStub.prototype.bindSpeechRecognitionAvailabilityObserver = function(observer) {
    return this.delegate_ && this.delegate_.bindSpeechRecognitionAvailabilityObserver && this.delegate_.bindSpeechRecognitionAvailabilityObserver(observer);
  }

  SpeechRecognitionClientBrowserInterfaceStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kSpeechRecognitionClientBrowserInterface_BindSpeechRecognitionAvailabilityObserver_Name:
      var params = reader.decodeStruct(SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionAvailabilityObserver_Params);
      this.bindSpeechRecognitionAvailabilityObserver(params.observer);
      return true;
    default:
      return false;
    }
  };

  SpeechRecognitionClientBrowserInterfaceStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateSpeechRecognitionClientBrowserInterfaceRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kSpeechRecognitionClientBrowserInterface_BindSpeechRecognitionAvailabilityObserver_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionAvailabilityObserver_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateSpeechRecognitionClientBrowserInterfaceResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var SpeechRecognitionClientBrowserInterface = {
    name: 'media.mojom.SpeechRecognitionClientBrowserInterface',
    kVersion: 0,
    ptrClass: SpeechRecognitionClientBrowserInterfacePtr,
    proxyClass: SpeechRecognitionClientBrowserInterfaceProxy,
    stubClass: SpeechRecognitionClientBrowserInterfaceStub,
    validateRequest: validateSpeechRecognitionClientBrowserInterfaceRequest,
    validateResponse: null,
  };
  SpeechRecognitionClientBrowserInterfaceStub.prototype.validator = validateSpeechRecognitionClientBrowserInterfaceRequest;
  SpeechRecognitionClientBrowserInterfaceProxy.prototype.validator = null;
  exports.SpeechRecognitionResult = SpeechRecognitionResult;
  exports.SpeechRecognitionContext = SpeechRecognitionContext;
  exports.SpeechRecognitionContextPtr = SpeechRecognitionContextPtr;
  exports.SpeechRecognitionContextAssociatedPtr = SpeechRecognitionContextAssociatedPtr;
  exports.SpeechRecognitionService = SpeechRecognitionService;
  exports.SpeechRecognitionServicePtr = SpeechRecognitionServicePtr;
  exports.SpeechRecognitionServiceAssociatedPtr = SpeechRecognitionServiceAssociatedPtr;
  exports.SpeechRecognitionServiceClient = SpeechRecognitionServiceClient;
  exports.SpeechRecognitionServiceClientPtr = SpeechRecognitionServiceClientPtr;
  exports.SpeechRecognitionServiceClientAssociatedPtr = SpeechRecognitionServiceClientAssociatedPtr;
  exports.SpeechRecognitionRecognizer = SpeechRecognitionRecognizer;
  exports.SpeechRecognitionRecognizerPtr = SpeechRecognitionRecognizerPtr;
  exports.SpeechRecognitionRecognizerAssociatedPtr = SpeechRecognitionRecognizerAssociatedPtr;
  exports.SpeechRecognitionRecognizerClient = SpeechRecognitionRecognizerClient;
  exports.SpeechRecognitionRecognizerClientPtr = SpeechRecognitionRecognizerClientPtr;
  exports.SpeechRecognitionRecognizerClientAssociatedPtr = SpeechRecognitionRecognizerClientAssociatedPtr;
  exports.SpeechRecognitionAvailabilityObserver = SpeechRecognitionAvailabilityObserver;
  exports.SpeechRecognitionAvailabilityObserverPtr = SpeechRecognitionAvailabilityObserverPtr;
  exports.SpeechRecognitionAvailabilityObserverAssociatedPtr = SpeechRecognitionAvailabilityObserverAssociatedPtr;
  exports.SpeechRecognitionClientBrowserInterface = SpeechRecognitionClientBrowserInterface;
  exports.SpeechRecognitionClientBrowserInterfacePtr = SpeechRecognitionClientBrowserInterfacePtr;
  exports.SpeechRecognitionClientBrowserInterfaceAssociatedPtr = SpeechRecognitionClientBrowserInterfaceAssociatedPtr;
})();