#include "ast.h"

#include "stmt.h"
namespace ast {
void node::print(const std::string& padding) const {
  if (id != nullptr) {
    if (end.data != nullptr) {
      std::cerr << padding << internal::demangle(id->name()) << " \""
                << std::string(begin.data, end.data) << "\" at "
                << position(begin, "") << " to " << position(end, "")
                << std::endl;
    } else {
      std::cerr << padding << internal::demangle(id->name()) << " at "
                << position(begin, "") << std::endl;
    }
  }
  if (!children.empty()) {
    for (auto& up : children) {
      node* n = cast<node*>(up.get());
      assert(n);
      n->print(padding + "  ");
    }
  }
}
std::string node::data() const {
  assert(end.data != nullptr && "This node does not contain data.");
  // First, throw away any whitespace at beginning and end
  auto begin = this->begin.data;
  auto end = this->end.data;
  while (isspace(*begin) && begin < end) {
    ++begin;
  }
  while (isspace(end[-1]) && begin < end) {
    --end;
  }

  // Now, make a string and return the contents
  return std::string(begin, end);
}
void node::add_source_buf(std::shared_ptr<std::string> source_buf) {
  if (this->source_buf) return;  // This already has its own source_buf
  for (const auto& child : children) {
    node* n = cast<node*>(child.get());
    n->add_source_buf(source_buf);
  }
  this->source_buf = source_buf;
}
void program::emit(ostream& os) {
  os << "// Intermediate representation, autogenerated.";
  os << R"EOF(
#include "runtime.h"
)EOF";
  for (const auto& child : children) {
    cast<stmt*>(child.get())->emit(os);
  }

  os << R"EOF(
int main() {
  std::cout << std::unitbuf; 
  std::cerr << std::unitbuf; 
  setvbuf(stdout, NULL, _IONBF, 0);
  setvbuf(stderr, NULL, _IONBF, 0);
  _exit(sbt_main());
}
)EOF";
}
}  // namespace ast
